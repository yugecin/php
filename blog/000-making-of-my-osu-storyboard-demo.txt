1535883433

Making of my osu! storyboard demo

02 Sep 2018
--------------------------------------------------------------------------------
{@img=blog/000/ytthumb.png;fragmented heart scene;YouTube thumbnail}

{@h2 Links}

{@ul
  {@li {@a=https://youtube.com/watch?v=bOGJWGJOMOk YouTube video showing the \
storyboard (original version)}}
  {@li {@a=https://youtube.com/watch?v=cPrhws8hevk YouTube video showing the \
storyboard (highfps version)}}
  {@li {@a=https://old.ppy.sh/b/1756941?m=0 Beatmap on osu! website}}
  {@li {@a=https://github.com/yugecin/osusb1 GitHub repo}}
  {@li {@a=https://github.com/yugecin/osusb1/releases GitHub releases}}
}

{@hr}

{@h2 Contents}

~INDEXGOESHERE~

{@hr}

{@h2 Prologue}

First things first, if you don't know what {@a=https://osu.ppy.sh/home osu!} is,
it's a rythm game where you have to click circles which are (hopefully) synced
with the music playing. There are multiple game modes, but the circle clicking
one (also called 'osu!standard') is the most popular one.

Beatmaps (which basically contain the music & metadata and describe when and
where circles, sliders, spinners, etc should be) can also include a video and/or
a storyboard. A storyboard, in its bare essence, describes a series of images
and each image can have a timed series of transformations that will be applied
to it (positioning/rotating/scaling/coloring).

If you're still completely in the dark, here's a nice video that shows what
gameplay with a storyboard in the background looks like (epilepsy warning):
{@a=https://www.youtube.com/watch?v=D112SbYXR3o YouTube: How beautiful can osu!
REALLY be? - Episode 2 [Sweet Dreams]}. Everything that happens in the
background is done using the storyboard. Amazing, right? Note that this is auto
mode, it's not a human playing.

{@h2 Backstory and timeline}

{@blockquote
robin_be: is anyone familiar with storyboarding?<br/>
Emily | Sunpy: I am somewhat familiar with it. But I havent done any
storyboarding in along time. But im guessing you are thinking about opsu
port?<br/>
robin_be: nah I'm planning something that's gonna fail miserably<br/>
robin_be: what is an .osb file?
}
{@caption yeah... silly me in #offtopic in Knorke discord, July 12th 2017}

{@h3 July 2017}

I can't exactly remember why I wanted to try out storyboarding. I think it's
because I wanted to try something different. If you recognize my username,
you might be familiar with my osu! cursordance videos. I made a few of those,
after being amazed by the work by
{@a=https://www.youtube.com/user/MrRheinerZufall MrRheinerZufall}. (This was
back in mid-2016). (I even
forked {@a=https://github.com/itdelatrisu/opsu opsu!} into {@a=https://github\
.com/yugecin/opsu-dance opsu!dance} to add cursordance-y stuff to it). I tried
to add something new or original into every video. If I didn't do that, every
video felt basically the same to me, and I don't like that. I hate seeing or
hearing the same thing over and over again. I don't listen to the (mainstream)
radio because after a while you notice they're always playing the same songs.
I don't understand how other people can stand that. Anyways, trying to have
something fresh every new video was getting pretty hard since I would say I'm
not really a person with lots of creativity. So I guess one day I just
randomly thought about doing something with storyboards.

I'm an avid follower of {@a=https://en.wikipedia.org/wiki/Demoscene the
demoscene} and the first idea I had (I think) was to try to remake the demo
{@a=https://www.youtube.com/watch?v=UYU5POqHdeA "What are you syncing about?"
by Ninjadev}, or at least some of the 2d parts. I saw it being released on the
live stream of the Revision 2017 demoparty. It was very nice to watch and it
looked like it would be possible to remake some of the parts in an osu!
storyboard. Especially the spaceship part that starts at 1m15s would be very
nice to see. I managed to hand-write storyboard commands to make everything
(except for the cubes and text) up to the 30s mark. The 3d pink-ish 'floor'
was pretty easy to fake with a few rectangular sprites. But the cubes are a
different story.

I had to get the cubes working. Otherwise there would be nothing special at
all about my storyboard. After all, it doesn't really have a story or
complements the beatmap that goes with it, because I wasn't going to make
a beatmap, just a storyboard. So it had to have at least something that would
be considered an 'achievement' or something that hasn't been done before. I
made some kind of helper program that would draw a wireframe cube which I
could rotate to try to match the cube in the video.

{@img=blog/000/20170715.png;program that draws a wireframe cube and has user \
controls on the right to change the cube's position and angles;;Yeah that \
looks horrible.}

I tried but the result looked horrible. The main culprit was that I thought
that move commands did not allow decimal numbers (spoiler: it does), which
is pretty essential if you want to have a good-looking wireframe cube. I blame
the osu!wiki for this. For some reason it stated that move commands do not
allow decimals. (I've submitted a pull request:
{@a=https://github.com/ppy/osu-wiki/pull/1660 ppy/osu-wiki PR#1660} to fix
this). I think I did try to use decimal numbers, but it gave an error when osu!
tried to parse the storyboard. Decimals {@i are} allowed, so osu! shouldn't
throw an error. I guess it's either a false memory or I managed to mess up
something else that made the command invalid.

{@img=blog/000/decimals.png;the move command specification on the osu!wiki, \
with a highlight on text that says decimals are not allowed;seriously?;I \
curse whoever wrote this.}

After failing that I think I just ditched the project, because it wasn't going
anywhere. No cubes, no glory.

{@blockquote meh apparently doing 3d stuff in storyboards is quite hard}
{@caption robin_be - July 16, 2017}

{@h3 February 2018}

After 7 months, I started looking into this again. Not sure how and why, that's
just what my git log says. On the 25th I made the first commit in that
repository, and it already had the projection code I would use for the rest of
this project. (More on that in the next section). Two days later I had a
wireframe cube storyboard that looked horrible because, again, I still didn't
know decimals were allowed in move commands. (Also I didn't scale the line width
down to 1 pixel so it looked extra bad).

{@img=blog/000/20180227.gif;a rotating wireframe cube but the lines don't \
connect and jump around;;It's a cube, but it doesn't look really good.}

{@h3 March 2018}

I then had the idea of making a large grid of pixels to make a cube. I think.
At least that's what happened, but I don't remember what I was thinking at that
time.

{@img=blog/000/20180304.gif;a rotating opaque pixelated cube;;An actual cube, \
amazing.}

It looked pretty good. It was relatively small, too. There were a few artifacts
though. Sometimes a few pixels would stay black for a frame when they should
change color. This was because I already tried to save some bytes, but it was
done in a way that basically said that the color should be black for 0
milliseconds, and somehow it actually showed black when running it. This was
fixed (way) later when Emily gave me some pointers on compressing.

{@blockquote this may have potential}
{@caption robin_be - March 4, 2018}

{@h3 May 2018}

After more weeks of hibernation and very low activity, I used some FFT output
for an attempt to make a 3d spectrum. The result is... a spectrum, but too low
quality to actually use. I could of course decrease the pixel size, but that
would enlarge the storyboard size. That was something to worry for later though,
first I needed more things to actually make something that would be interesting.

{@img=blog/000/20180517.gif;a rotating pixelated 3d spectrum;;Every good \
storyboard needs a spectrum right?}

On a very sunny sunday, I went outside and spent a good two hours solving my
rubik's cube. The reason it took so long was because I was trying to note down
every move I made, so I can use that to scramble and solve a rubik's cube in the
storyboard. But I kept messing up, either by writing down wrong moves, or by
messing up while redoing the moves I wrote down. Eventually I have a series of
moves that split up into two branches, then came together again, only to be
split again in two branches. So then I had to figure out what parts of what
branches were correct. I didn't want to start over again because this scramble
and solution didn't have many moves and I knew I had to keep the amount of
moves low so that the rubik's cube scene wouldn't become too long. So yeah, two
(if not more) hours...

{@img=blog/000/20180506.jpg;garden with 2 chairs, one having a notebook and a \
rubik's cube on it;;What a beautiful day that was.}

One other shape I had in mind was a torus. It was relatively easy to generate
points to make one, as expected. The result came out to be pretty nice.

{@img=blog/000/31052018.jpg;a pixelated green torus;;Anyone fancy a torus?}

{@h3 June 2018}

As for song choice, I had been looking at some tracks by Renard and lapfox
tracks etc in an attempt to find something energetic that would fit with a
demoscene-y storyboard. To get some inspiration for what to do in my
storyboard, I was regulary looking at {@a=https://www.youtube.com/playlist?\
list=PLzAbz5PweIWTtwwGhznh1Y6cvlo_Oo8RE BGA videos}. Eventually I stumbled
upon {@a=https://www.youtube.com/watch?v=xJqN4RUyxIE sky_delta - Exordium}. This
seemed like a really nice song to complement a demo-ish storyboard, so this
became my new pick. It also gave me some new ideas of things I could do (does
the tetrahedron flying through the tunnel look familiar?).

{@h3 July 2018}

In July, I flew to Norway and went to the {@a=http://www.solskogen.no \
Solskogen demoparty} together with Emily (best few days of my life \o/). While
being there, I told her what I was trying to do and showed what I had, which was
basically only a pixelated cube and a shaded torus. It was kind of a funny
moment when I explained that I was basically coloring pixel sprites in order to
display a spinning cube... :D. When I told her about the decimals thing, she
checked the source and actually saw that it does accept decimals. I'm not sure
what happened but I don't think I tried to test or use it after she told me...

About two weeks after that, things really took off. Emily tried to make a
wireframe cube. I was pretty sure it wasn't going to work, since I still
believed that decimals weren't possible in move commands, so I thought it
couldn't possibly look good. She took some old javascript code to draw a 3d
cube and took that as base to generate a short storyboard. We were in a call
at that time and I was helping a bit with the math aspect. It was getting pretty
late so I went to bed. The next day when I opened Discord, I was greeted with
the following picture and an accompanying storyboard file.

{@img=blog/000/27072018.png;a 3d wireframe cube in osu!;;Yup, that's one good \
looking cube.}

Seeing that was a magic moment to me. All I had seen before was my own attempt,
which was horrible. Now Emily made a cube with lines that are joined perfectly.
It was amazing.

{@blockquote fuck me for thinking it's not possible}
{@caption robin_be - July 27, 2018}

Barely a day later Emily found a method of making opaque surfaces. After that
I basically worked on it every day, because now I knew it was possible to do
some more awesome things. Also because I finally managed to fix the whole
rubik's cube movement code. It took me a looooong time to get that right and
it was very demotivating since nothing I thought of seemed to work.

{@img=blog/000/commits.png;commit graph of the project, it has a little spike \
around May and June, and a huge spike at the end of July and mid August;;\
Commit history of the project's repository.}

{@h3 August 2018}

In the beginning of August, the song of choice changed one last time. I am
subscribed to a YouTube channel named {@a=https://www.youtube.com/user/\
jjbbllkk Red Means Recording} because the person behind it makes some
interesting videos wherein he makes music using some interesting synthesizer
things (I don't actually know much about it, but I like what he's creating...).
One day he uploaded this video:
{@a=https://www.youtube.com/watch?v=sM0flzYWjcs I Made YouTube Library Music \
For You}. I took a look at it, because why not, and it had a few songs that I
though were suitable as music for this project. When I heard "Flex", I
instantly thought I found something. It has some nice buildups, which can be
useful for demo-ish stuffs, and it's a pretty nice song overall. It is a bit
long, but I figured I didn't have to fill the entire length. It ended up being
the song for the final version.

{@h1 don't forget to change the date when finishing this}

{@h2 Techniques and approach}

To make life easier, I made two important (no-brainer) decisions before even
starting. One was that I was not just going something that would dump out
storyboard commands, but a program that would actually render what I was coding.
It would be incredibly time consuming and stupid if I had to export the
storyboard and check in osu! everytime I did a little change. Not only that,
but there's zero chance that I would get the storyboard commands correctly from
the start, so that would make debugging very tedious and even more time
consuming.

The other decision was that everything had to be deterministic. By that I mean
that I should just be able to give a certain timestamp, and the program should
calculate the result that should be visible on that specific timestamp. This
means no state at all. It would be very stupid to not do it this way, because
jumping around in time would mess up everything.

<pre>
float startx = 100;
float endx = 500;
int endtime = 3000;
Cube cube = new Cube(startx, 0, 0);
void draw(int time) {
	cube.position.x += (endx - startx) / endtime;
	cube.draw();
}
</pre>
{@caption Pseudocode, moving a cube the wrong (non-deterministic) way.}

In the example above, if you would want to see what the scene looks like at time
2000, you would need to draw the scene for every millisecond until you get at
time 2000. Otherwise the cube's position won't be correct, since it wouldn't
have done the movements that are being made in the previous frames. This also
means it's not possible to go back in time.

By using the code in the example below, you can seek as much as you want. The
cube's position will always be correct for the given time, since it only depends
on the time value and not on how many times the scene has rendered before.

<pre>
float startx = 100;
float endx = 500;
int endtime = 3000;
Cube cube = new Cube(startx, 0, 0);
void draw(int time) {
	float progress = time / endtime;
	cube.position.x = (endx - startx) * progress;
	cube.draw();
}
</pre>
{@caption Pseudocode, moving a cube the correct (deterministic) way.}

That being said, generating all the storyboard commands works by rendering the
scenes from start to end while collecting information about every object's
position.

{@h3 Application}

{@img=blog/000/app.gif;gif showing the application with the tunnel + spectrum \
scene, demonstrating how the camera can be rotated by dragging the mouse\
;;Looking around in the tunnel + spectrum scene}

I decided to make the program in C#. I'm more familiar with Java, but C#
seemed like the obvious choice since making GUI stuff is very easy using Visual
Studio.

The GUI itself is pretty simple. No need for anything complicated. The most
important parts are the {@code PictureBox} where everything gets rendered and
the {@code NumericUpDown} control in the bottom left, to change the time. There
are also quite a few {@code TrackBar}s at the right, which can be used anywhere
in the code to change values to test without having to recompile and restart
the program. I didn't end up using it much at all though. I think the only time
I really had to use it was to get the rotation movements correct in the very
first scene with the wireframe cube and text.

Mouse dragging events in the preview rectangle were saved so scenes could use
that data to change angles, effectively allowing me to 'look around' in the
world.

{@img=blog/000/app2.gif;gif showing the application with the 'Emily' 3D text \
scene, demonstrating object movement with sliders and camera movement with \
mouse;;Moving Emily around :3c}

{@h3 Scenes}

The whole storyboard is divided in different scenes. For example, the tunnel
is one scene, the rubik's cube is in a different scene, ... Each scene has its
own start and stop time, so it will only be rendered if the current time falls
inbetween that. Additionally, each scene has its own framedelta, so scenes can
be rendered at a different FPS. Example: the heart is rendered at 7.4 FPS
while the torus field gets 20 FPS.

Two scenes actually have a non-constant FPS. The tunnel scene starts with a
framedelta of 900 so that it will have one frame at the start and one frame
after the tunnel has flown in. That makes the fly-in effect look smooth because
it's a single interpolation between 2 frames. After that, its framedelta
changes to 300.

The torus field scene starts with a framedelta so that the second frame will
be in sync with the audio, then it changes its framedelta so the third frame
will be in sync with the audio, and then it changes the framedelta once more
to the normal value to have a nice fps.

Note that this fps thing only applies when exporting to a storyboard, so it
doesn't affect the preview in the application.

{@h3 Exporting to storyboard}

As I kind of mentioned before, generating the storyboard is done by rendering
the scenes every 5 milliseconds, starting from the scene with the earliest
starttime to the scene with the latest endtime. While this is happening,
sprites and commands are being generated and saved into lists.

Looking closer at the code, there is an {@code Odot} class (Object: dot), which
is used to track a dot. Other objects are {@code Orect} for rectangles (3d
rectangles so actually just 4 point filled polygons), {@code Otri} (which is
not used directly, each {@code Orect} makes 4 of these: see
{@#=Opaque surfaces| opaque surfaces}) and {@code Oline} for a line between two
points. There's also {@code Odottedrect} which makes a field of {@code Odot}s
inside a rectangle (this is only used in the {@#=Rubik's cube| rubik's cube \
scene}).

<pre>
Odot dot;
public override void draw(SCENE scene) {
	float angle = scene.progress * 7f;
	vec3 pos = v3(30f * sin(angle), 20f * cos(angle), 100f);
	vec4 color = v4(1f, 0f, scene.progress, 1f);
	float size = 6f + 2f * scene.progress;
	vec4 p = project(pos);
	if (p.w > 95f) {
		dot.update(scene.time, color, p, size);
	} else {
		dot.update(scene.time, null, null, size);
	}
	dot.draw(scene.g);
}

public override void fin(Writer w) {
	dot.fin(w);
}
</pre>
{@caption Sample scene that draws a dot spinning in 3d space.}

This example scene has only one dot. It spins around in 3d space (but this is
not really noticable), the color changes from red at the start to magenta at
the end, and it grows from {@code 6} units to {@code 8} units in size. The dot
only shows if its distance to the camera is more than {@code 95} units (the
{@code w} component of a {@code vec4} projection result gets set to the
distance from the projected point to the camera).

The {@code dot.draw} method is only needed to draw the dot inside the preview in
the application, it doesn't do anything during exporting.

The {@code fin} method gets called after everything is rendered and the sprite
should process the commands and write it to the storyboard file.

<pre>
Sprite,Foreground,Centre,d,0,0
_M,0,0,,320,224
_C,0,0,,255,0,0
_M,0,100,,396.6,224
_C,0,100,,255,0,25
_M,0,200,300,450.7,224
_C,0,200,,255,0,51
_S,0,200,,1.1
Sprite,Foreground,Centre,d,0,0
_M,0,700,,190.1,224
_C,0,700,,255,0,178
_S,0,700,,1.2
_M,0,800,,245.1,224
_C,0,800,,255,0,204
_S,0,800,,1.3
_M,0,900,1000,321.9,224
_C,0,900,,255,0,229
</pre>
{@caption Scene above exported to a storyboard.}

Note: this storyboard code is partially compressed, see {@#=Compression| \
compression} for more information.

This scene was set to have a framedelta of {@code 100}. The resulting storyboard
has 2 sprites to represent this single dot. This is because the dot is not
visible during some time (when the distance to the camera is less than or equal
to {@code 95} units, as written in the scene's code). It is of course possible
to just hide the sprite and reuse it later when it becomes visible again. I did
this in the beginning, but the generated storyboard is larger when doing this as
opposed to just ditching the old sprite and making a new one when needed again.

Every time {@code dot.update} was called, it checked for every property
(position, color, opacity, scale) if the value is too different from the value
in the previous command. If so, it will generate a new command for the property
and add it to the list of commands. This is noticable for the scale command.
While there are move and color commands for every frame, there are only 3 scale
commands. This is because the value was rounded (in this case) to have only one
decimal, and it is of course not needed to add a command every frame if the
value didn't change from the previous frame/command. Note that this actually
needs another scale command in the beginning to have a correct start value, see
{@#=Default value quirk| default value quirk} for details.

{@h4 Last frame adjustments}

In almost every command in the generated example above, there is no endtime
specified. This is because the endtime should be the same as the starttime, and
if these are the same, the endtime can just be omitted to save space (see also
{@#=End time and end values| end time and end values}). Only the last move
command of both sprites has a different endtime. The reason behind this is that
sprites are only visible from their lowest starttime in any command to the
highest endtime in any command. This means that if the latest endtime is 900,
the sprite will be visible at time 900 and disappear at time 901. But in this
case, 900 is the time where the last frame starts, and that frame that should
be visible from time 900 to 1000 (or rather, 999). This means the last frame
will never be shown (or just for a millisecond). This leads to missing sprites,
broken objects, and this potentially leaves a blank few milliseconds in the
storyboard if that frame is the last one of its scene. To fix this, the last
command (in this case, the last move command), will have its endtime changed to
the time that the frame should end.

{@h4 Adding interpolation}

Only setting values at specific times using commands is not that great to make
movement. To have motion that's more smooth, it would need a lot of commands
with a tiny framedelta. Another options is to add (or rather, use)
interpolation. Adding interpolation between the 2d projected positions isn't
very correct, but it's not so noticable either. At least for the dots, if I try
to add interpolation to the 3d objects (spectrum, heart, text), it fails
miserably, expected. This is because those need very precise position / scaling
/ rotation, which is not possible to interpolate (see {@#=Opaque surfaces| \
opaque surfaces}).

<pre>
Sprite,Foreground,Centre,d,0,0
_M,0,0,100,320,224,396.6,224
_C,0,0,,255,0,0
_M,0,100,200,396.6,224,450.7,224
_C,0,100,,255,0,25
_C,0,200,,255,0,51
_S,0,200,,1.1
Sprite,Foreground,Centre,d,0,0
_M,0,700,800,190.1,224,245.1,224
_C,0,700,,255,0,178
_S,0,700,800,1.2,1.3
_M,0,800,900,245.1,224,321.9,224
_C,0,800,,255,0,204
_C,0,900,,255,0,229
</pre>
{@caption Same scene as before, but with movement and scaling easing applied.}

While writing this, I just remembered I didn't add interpolation for the color
because it was not needed, so only the move and scale commands are eased in this
example. Now each move command has an endtime that is different from the
starttime, and the end position is also different from the starting position.
Same for the scale commands.

You may have noticed that the ending time is again wrong since the last frame
for the first sprite is at time 300, but the last command only goes to time 200
(the same applies to the second sprite). This is because there is no next frame
to interpolate to, so this is pretty much unavoidable. The last frame adjustment
technique can't be used because that would add a still frame at the end while
it was moving before. To minimize this though, the scene's time can be extended
to be a bit longer, compensating the missing frame's duration. If a sprite goes
out of bounds, I'm also allowing one frame with out of bounds positions so it
can interpolate to the edge of the screen instead of just disappearing. Same
for when a sprite appears from an out of bounds position.

<pre>
without interpolation:
100-200: A, 200-300: B, 300-400: C

with interpolation:
100-200: A->B, 200-300: B->C, 300-400: nothing to interpolate C to
</pre>
{@caption More clear example why the last frame is missing when interpolating.}

{@h4 Phantom frames}

An issue showed up once I started interpolating positions, as shown in the
picture below. The left image is one frame, the right image is the next frame.
The image in the middle is what happens between those frames. All the squares
are being interpolated from frame 1's position to the position they should be in
frame 2. The problem is that some squares that are not visible in frame 1 should
suddenly become visible while they're being transitioned into frame 2's
position. But of course they aren't becoming visible since there's no frame that
processes it at that point in time.

The same effect is also visible in the right image. The grey surface in between
the cube's sections should still be visible. But this is a capture between that
frame and the next frame, and since that grey surface is not visible in the next
frame, it is already invisible because there's no position to interpolate to.

{@img=blog/000/cubs.png;3 captures of the rukbik's cube scene, the 2nd capture \
has missing pixels on a part that is moving;;Black hole warning.}

The solution I made was to introduce so-called "phantom frames". Frames that
don't really exist. Every scene now also had a phantom framedelta. For most
scenes, the value is the same as the framedelta because it doesn't need phantom
processing. Every command that is generated by a phantom frame is marked as a
phantom command. Since sprites are never reused, only the very first and last
commands are being checked if they're phantom commands. If they are, they get
"promoted" to a real command. All the other phantom commands are just ditched.

The only scenes that used phantom frames/commands are the {@#=Rubik's cube| \
rubik's cube} and {@#=Starfield torus| starfield torus} scenes.

{@h4 Default value quirk}

this actually also made things easier (phantom commands)

{@h4 Output report}

{@img=blog/000/export.png;image of the console showing how many KB each scene \
is, and usage count of sprites and ease commands;;The output when exporting \
to a storyboard file.}

{@h3 Type 'library'}

{@h3 3d projection}

{@blockquote "use the tools that you have" on a whole new level}

{@h4 Intermezzo: .NET float parsing bullshit}

{@blockquote (times I have been fucked by C# treating a comma as decimal
separator for float.Parse() and using a . as thousand separator)++}
{@caption robin_be - March 4, 2018}

For some reason C# (or .NET in general?) parses floats by using the 'Region
and Language' that has been setup in the control panel. In my case, that
means it would use a {@code ,} as decimal separator and a {@code .} as
thousand separator. It's a pretty easy fix but for some reason it usually
takes me a while to realize that that's what causing the weird
{@code float.Parse} behavior that I'm seeing.

<pre>
var c = (CultureInfo) Thread.CurrentThread.CurrentCulture.Clone();
c.NumberFormat.NumberDecimalSeparator = ".";
Thread.CurrentThread.CurrentCulture = c;
</pre>
{@caption Take that, annoying region and language settings!}

{@h3 Rasterisation}

{@h3 Opaque surfaces}

{@h3 Opaque 3d objects}

{@h3 FFT}

{@h3 Font rendering}

{@h2 Scene breakdown}

{@h3 Intro cube}

{@h3 Tunnel}

{@h3 Spectrum}

{@h3 Rubik's cube}

{@h3 Waves}

{@h3 Heart}

{@h3 Greetings}

{@h3 Torus field}

{@h3 Checkerboard and 3d text}

{@h3 Starfield torus}

{@h2 Compression}

Everything about reducing the size of the resulting storyboard file.

Fun fact: when saving the beatmap using the editor in osu!, its size goes from
27MB to 32.6MB (without variables).

{@h3 Line endings}

When I was messing with osb files in the very beginning to see how it all works,
I noticed the line endings and realised a very easy way to lose some weight is
to use {@code LF} instead of .NET's default {@code CRLF}. This saves one byte
per line, which may not seem like a lot, but this saves almost a full megabyte
since my storyboard ended up to be about 977K lines.

{@h3 Sprite names}

Changing sprite names to save some space was also a no-brainer. The osu!wiki
shows a sample object declaration like this: {@code Sprite,Pass,Centre,"Text\
\Play2-HaveFunH.png",320,240}. First of all, if you're making a storyboard
like this (that will have lots of object declarations), why wouldn't you use
a filename that's as short as possible? I've seen storyboard that use
filename like {@code SB\alien\spaceship.png}. Maybe it might be a bit
annoying while you're working on it (not for me since keeping track of only
4 sprites is not that hard x3), but you can always change it to something
shorter at the end.

So I gave my sprites each only one letter as filename. The wiki states that
the quotes are only really needed when the path has spaces in it, so I could
ditch those too. Me being curious tried to remove the extension as well, and
that seems to work just fine. So I my object declarations looked more or
less like this: {@code Sprite,Foreground,Centre,d,0,0}.

Then I thought, what would happen if I use an empty filename? So I tried just
that, and it works too! I changed the most used sprite to just {@code .png}
and loaded it by doing {@code Sprite,Foreground,Centre,,0,0}. The only side
effect that this seems to have is that it crashes osu! when you try to open
the sprite browser in the editor. You don't even have to use the sprite, just
having a filename with only an extension in the directory makes this happen.

{@img=blog/000/spritelibcrash.png;osu! crash reporter showing an \
IndexOutOfRangeException;;Check your string lengths!}

After applying {@#=Variables| variables}, changing the sprite names to something
as short as possible doesn't really matter much anymore but it's a fun thing
to have, why not.

{@h3 Sprite sizes}

This is not really related to the storyboard file, but why not make the sprite
files themselves as small as possible? One of my favorite tools is
{@a=https://pngquant.org/ pngquant}, which compresses png files (and does this
really well).

I use {@a=https://www.getpaint.net/ Paint.NET} for image editing
(I shake my head at people who (illegally) use Adobe Photoshop to do simple
image editing...), which adds 24 bytes of metadata to PNG files so everyone that
looks at the PNG headers can see it was made with Paint.NET. It's not hard to
remove that using a hex editor, so that's another easy 24 bytes per sprite.

When I changed my 3x3 sprite into a 2x2 sprite, I noticed that the filesize
stayed the same (122 bytes). I found that quite peculiar, so I mentioned it in
the osu!fx discord. HoLLy responded that I should use a bitmap, which would
probably be a lot smaller. The BMP header was a lot bigger than he expected,
but the resulting file was still smaller, at only 70 bytes. When I checked it
in osu!  I saw that it didn't load the sprite. It seems like it would only
check for {@code .png} and maybe {@code .jpg} files when there's no file
extension in the object declaration. Then HoLLy saved the day again, but
saying I should just rename the file to a {@code .png}, since .NET apparently
uses 1 method to load all images. Renaming the file worked, so I now had a
sprite that was smaller than its PNG counterpart and I didn't have to specify
the extension in the object declarations.

Yes I know optimizing the sprite sizes by removing some bytes is nothing
compared to the larger part but if it can be smaller with almost no effort,
why not do it amirite?

{@h3 Enum member values}

Back when we were at Solskogen, Emily found out that several values were parsed
using {@code Enum.Parse}. This allows us to write {@code 4,3,1,d,0,0} instead of
{@code Sprite,Foreground,Centre,d,0,0}. Pretty neat, I would be surprised if
anyone found out about that before. I've always wondered why the object
declarations had to be written using those long words. It might make it easier
to read the osb file (for humans), but at the end storyboards can have so many
objects it's just unnecessarily taking up lots of space. But I guess the
developers didn't really imagine people would add lots of particles and (faux)
3d objects in their storyboards.

This also works for sections names, so {@code [Events]} can be written as
{@code [32]}, {@code [Variables]} is {@code [256]}, etc etc. These values can
be found nowadays in the osu repository: {@a=https://github.com/ppy/osu/blob/\
5e5a74293e2710690328dda0086ec0fe9617ac24/osu.Game/Beatmaps/Formats/\
LegacyDecoder.cs#L127 LegacyDecoder.cs in ppy/osu}. Note that they messed it
up there, the values for the sections are wrong.

<pre>
protected enum Section
{
    None = 0,
    General = 1,
    Editor = 2,
    Metadata = 4,
    Difficulty = 8,
    Events = 16,
    TimingPoints = 32,
    Colours = 64,
    HitObjects = 128,
    Variables = 256,
    Fonts = 512
}
</pre>
{@caption The correct values for the sections.}

Emily also made a pull request to add the values in the osu!wiki:
{@a=https://github.com/ppy/osu-wiki/pull/1675 ppy/osu-wiki PR#1675}.

{@h3 End time and end values}

I'm not sure when this happened (it was definitely after Solskogen), but
Emily showed me that you can just leave out the end time if it's the same as
the start time. So you can minimize {@code _F,0,10000,10000,0,1} to just
{@code _F,0,10000,,0,1}. Same with the end values, you can leave them out if
they're the same as the start values, thus {@code _M,0,2000,2000,174.1,232.2\
,174.1,232.2} becomes {@code _M,0,2000,,174.1,232.2} and so on.

This saved lots of space and also fixed a bug I had earlier. When I didn't
know about this, I also tried to save space by putting small values as the
start values. For example, to change the color to white I would write
{@code _C,0,100,100,0,0,0,255,255,255}. The initial values are set to {@code 0}
because one digit is two bytes less than three digits, and since the end time
is the same as the start time, I figured it shouldn't be visible that the start
color was black. It wasn't visible most of the times, but every once in a while
there is a certain point where all my sprites would turn black for a very short
period. I'm not sure how that works, since the interpolation duration is always
0ms, but it happened, so it was not the best way to try to save some space.
Thanks to this new method Emily told me about, I was saving even more space and
without the bugs I experienced earlier. Yay!

{@h3 Shorthand discoveries}

When I was writing this post, I checked the osu!wiki for reference multiple
times. Suddenly I noticed following line on the {@a=https://osu.ppy.sh/help/\
wiki/Storyboard_Scripting/Commands storyboard scripting commands} page.

{@img=blog/000/shorthand.png;Screenshot of a sentence on the wiki: 'see the \
shorthand section for an explanation of how to shorten this last line to \
just _F,0,1000,3000,1';;What?}

I checked the whole page, but this is the only place that mentions these
so-called "shorthands". I went to the {@a=https://github.com/ppy/osu-wiki
osu-wiki repository on github} and searched for "shorthand". I found out that
there is a page that I've never seen before. It basically describes what I
explained in the previous section, that you can leave out end times and end
values when they're the same as the start time and start values, respectively.

But that page also mentioned a third case of shorthands, which is when a command
has sequential values changes with the same interval. I'm having a hard time
describing this so just check the following example.

<pre>
// the 'normal' way
_F,0,1000,2000,0,0.5
_F,0,2000,3000,0.5,0
_F,0,3000,4000,0,1
_F,0,4000,5000,1,0

// the 'shorthand' way
_F,0,1000,2000,0,0.5,0,1,0
</pre>
{@caption Holy compression.}

I was amazed when I saw this. Sadly I already released the map and the video
at this point, but I still implemented it. By using this, the map's size was
reduced by another 3.5MB. This was to good to just leave it, so I updated the
map on the website to include these changes.

This page about shorthands is not linked anywhere on the wiki though, so it's
very hard to find. I was kind of slightly mad about this because I had no idea
due to how bad the new osu wiki is made/linked. Some people were impressed that
I managed to make this storyboard while it's only 25MB in size, but in reality
it could've been 22MB in size without any difference in the resulting visuals.

To be more precise, the page is actually linked on the Sitemap page, but that
page is not linked anywhere. But wait, there's more! The Sitemap page is linked
from a page named {@code Main_Page}, but that page doesn't even exist on the
live version, it only exists in the osu!wiki repository. I don't even...  I made
a pull request: {@a=https://github.com/ppy/osu-wiki/pull/1661 osu-wiki PR#1661}
to add a link to the shorthand page, so hopefully that will be fixed soon.

{@b Note:} my pull request was merged before I even finished this blogpost, so
yey!

{@h3 Initial position}

In an object declaration, one can specify the position of the sprite. Now of
course this doesn't have any meaning if the sprite is moved from the start, so
this can be set to {@code 0,0} instead of the actual start location to save some
quick bytes. Actually it is useless in that case anyways because of the
{@#=Default value quirk| default value quirk}. I have 34847 sprites like this,
so this saved about 146KB (34847x4.2 because 2 digits for each coordinate and on
(guessed) average 0.2 bytes per sprite in case negative coordinates are used
because it's a widescreen storyboard).

If the sprite is only going to move in the x or y direction, one coordinate
could be set and the {@code _MX} or {@code _MY} command could be used to move
the sprite. This is what I did for the text in the {@#=Starfield torus| \
starfield torus} scene. I set the initial position's x coordinate to zero and
the y coordinate to whatever y position it should be on, and use the {@code _MX}
command to move the sprite horizontally. This saves about 5 bytes per pixel used
to make the text (and there are 2725 of those so it saved 16KB).

In retrospect I thought I would've saved more if I didn't do that, because using
{@#=Variables| variables} might saved more. But I checked (just now), and by
using variables it could've saved at maximum (using my current configration) 5
bytes. Since there are lots of variable, I needed to use 2 byte identifiers
because I ran out of characters. This means there was a high chance that it
would've only saved 4 bytes instead of 5 bytes, so using this method was a good
(lucky) call.

{@h3 Rounding decimal values}

Another quick way to shave off some bytes is to reduce the amound of decimals.
Very high precision is not always needed/noticed anyways. Only for the scenes
with 3d opaque surfaces, like the spectrum and the heart, it is needed to have a
high precision because otherwise the sprites wouldn't join nicely together and
it would look slightly worse. I made it round to 5 decimals for these scenes,
but even then it is sometimes visible that the sprites don't completely join.
For the other scenes, it was mostly rounded to 1 decimal because it doesn't
matter if the movement of the dots are slightly off.

<pre>
public override void draw(SCENE scene) {
	ICommand.round_scale_decimals.Push(2);
	// ...
	ICommand.round_scale_decimals.Pop();
}

public override void fin(Writer w) {
	ICommand.round_scale_decimals.Push(2);
	// ...
	ICommand.round_scale_decimals.Pop();
}
</pre>
{@caption How the rounding is dynamically configured.}

{@h3 Combining multiple fade/scale commands}

One more thing to save space (and actually make things smoother at the same
time) is to combine series of fade/scale commands into only one command by
applying an easing that fits with the way the value changes. Consider the
following example:

<pre>
Odot dot;
public override void draw(SCENE scene) {
	float angle = scene.progress * 7f;
	vec3 pos = v3(20f * sin(angle), 20f * cos(angle), 100f);
	vec4 p = project(pos);
	float size = progressx(130f, 70f, p.w) * 12f;
	dot.update(scene.time, v4(1f), p, size);
}
</pre>
{@caption Simple scene with a spinning dot that gets larger as it gets \
closer to the camera.}

<pre>
4,3,1,d,0,0
_S,0,0,,0.3
_S,0,100,,0.5
_S,0,200,,0.8
_S,0,300,,1.3
_S,0,400,,1.6
_S,0,600,,1.3
_S,0,700,,0.8
_S,0,800,,0.5
_S,0,900,,0.3
</pre>
{@caption Storyboard code generated by the above scene. Note that I removed \
the move commands for this example.}

In the generated storyboard code you can see that the value goes up, and then
goes down again. The idea is to split all these commands of the same category
in batches where the value changes in the same direction (goes up or down).
Then one single command gets made with the start data of the first one and the
end data of the last one. For each batch, go through all possible easing
equations that osu! has to offer and see by using which easing the values get
the closest to the target values given at each command in the batch. The best
one is being determined by the score given to it, which depends on the average
difference and the maximum difference between the eased values and the target
values.

{@img=blog/000/easing.png;a graph showing the target value and values \
calculated with each easing;;Graph with easings for the first batch. Red is \
the target, green is the one with the best score.}

Since the scale value in the previous example goes up once and then down once,
the commands are split into two batches. The graph above is a visualisation of
the first batch. The red line represents the target values, the green line
represents the values with easing 15 applied, which is the easing with the best
score.

The resulting two scale commands use easings 15 (sine in) and 16 (sine out),
which makes sense since the dot's position (and thus size) was largely
determined by a sine wave motion.

<pre>
4,3,1,d,0,0
_S,15,0,400,0.33,1.62
_S,16,500,900,1.61,0.33
</pre>
{@caption Storyboard commands for the same scene, but with easing as explained \
applied.}

According to the {@#=Output report| output report}, combining commands like this
was done 11655 times, saving 61211 commands and about 760KB. On top of the space
savings, this also means the scaling or fading will be a bit smoother compared
to chained linear interpolated commands. The reason that the linear
interpolation was applied so many times is probably due to many batches only
having two commands.

{@img=blog/000/easingusage.png;bar-graph with pink bars... too much data to \
type down sorry;;Graph showing how much each easing is applied (slightly off). \
Note the logarithmic x-axis.}

Now I'm wondering why I didn't try to do this with the move commands... On a
second thought, this would be very hard to do for the move commands. Fade and
scale are only single float values, so it can only go up or down. That means
it's relatively easy to split batches of commands depending on whether the value
is going up or down. It would be way more complex to do this for move commands,
since those have two values that change instead of only one.

{@h3 Variables}

{@img=blog/000/minify.png;image of the console showing variable process \
progress and the top variable replacements;;The output when minifying using \
variables.}

{@h4 Staircase of death}

{@blockquote we should call this the staircase of death}
{@caption Emily - August 26, 2018}

{@h5 Upload failure}

{@h4 Stable vs Lazer}

Only sequential nesting is possible when using variables. However, in Lazer,
proper nesting seems to be supported.

{@h2 Related work}

dualife, flower trip, (others I can't remember atm)

those had 3d wireframe objects, back in 2016. I found out about them when I
was almost finished with my storyboard. I wish I saw them earlier, so I would
know that decimals in move commands are allowed. Still, bad from my end that
I didn't try enough to actually see if it was possible.

{@h2 Epilogue}

SB load?
link her blog
NaN and +Inf
tweet

{@hr}

{@blockquote also, turns out writing a blogpost takes a long while &lt;.&lt;}
{@caption robin_be - September 3, 2018}



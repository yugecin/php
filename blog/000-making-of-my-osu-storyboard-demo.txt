1535883433

Making of my osu! storyboard demo

02 Sep 2018
--------------------------------------------------------------------------------
{@img=blog/000/ytthumb.png;fragmented heart scene;YouTube thumbnail}

{@h2 Links}

{@ul
  {@li {@a=https://youtube.com/watch?v=bOGJWGJOMOk YouTube video showing the \
storyboard}}
  {@li {@a=https://old.ppy.sh/b/1756941?m=0 Beatmap on osu! website}}
  {@li {@a=https://github.com/yugecin/osusb1 GitHub repo}}
  {@li {@a=https://github.com/yugecin/osusb1/releases GitHub releases}}
}

{@hr}

{@h2 Contents}

~INDEXGOESHERE~

{@hr}

{@h2 Prologue}

First things first, if you don't know what {@a=https://osu.ppy.sh/home osu!} is,
it's a rythm game where you have to click circles which are (hopefully) synced
with the music playing. There are multiple game modes, but the circle clicking
one (also called 'osu!standard') is the most popular one.

Beatmaps (which basically contain the music & metadata and describe when and
where circles, sliders, spinners, etc should be) can also include a video and/or
a storyboard. A storyboard, in its bare essence, describes a series of images
and each image can have a timed series of transformations that will be applied
to it (positioning/rotating/scaling/coloring).

If you're still completely in the dark, here's a nice video that shows what
gameplay with a storyboard in the background looks like (epilepsy warning):
{@a=https://www.youtube.com/watch?v=D112SbYXR3o YouTube: How beautiful can osu!
REALLY be? - Episode 2 [Sweet Dreams]}. Everything that happens in the
background is done using the storyboard. Amazing, right? Note that this is auto
mode, it's not a human playing.

{@h2 Backstory and timeline}

{@blockquote
robin_be: is anyone familiar with storyboarding?<br/>
Emily | Sunpy: I am somewhat familiar with it. But I havent done any
storyboarding in along time. But im guessing you are thinking about opsu
port?<br/>
robin_be: nah I'm planning something that's gonna fail miserably<br/>
robin_be: what is an .osb file?
}
{@caption yeah... silly me in #offtopic in Knorke discord, July 12th 2017}

{@h3 July 2017}

I can't exactly remember why I wanted to try out storyboarding. I think it's
because I wanted to try something different. If you recognize my username,
you might be familiar with my osu! cursordance videos. I made a few of those,
after being amazed by the work by
{@a=https://www.youtube.com/user/MrRheinerZufall MrRheinerZufall}. (This was
back in mid-2016). (I even
forked {@a=https://github.com/itdelatrisu/opsu opsu!} into {@a=https://github\
.com/yugecin/opsu-dance opsu!dance} to add cursordance-y stuff to it). I tried
to add something new or original into every video. If I didn't do that, every
video felt basically the same to me, and I don't like that. I hate seeing or
hearing the same thing over and over again. I don't listen to the (mainstream)
radio because after a while you notice they're always playing the same songs.
I don't understand how other people can stand that. Anyways, trying to have
something fresh every new video was getting pretty hard since I would say I'm
not really a person with lots of creativity. So I guess one day I just
randomly thought about doing something with storyboards.

I'm an avid follower of {@a=https://en.wikipedia.org/wiki/Demoscene the
demoscene} and the first idea I had (I think) was to try to remake the demo
{@a=https://www.youtube.com/watch?v=UYU5POqHdeA "What are you syncing about?"
by Ninjadev}, or at least some of the 2d parts. I saw it being released on the
live stream of the Revision 2017 demoparty. It was very nice to watch and it
looked like it would be possible to remake some of the parts in an osu!
storyboard. Especially the spaceship part that starts at 1m15s would be very
nice to see. I managed to hand-write storyboard commands to make everything
(except for the cubes and text) up to the 30s mark. The 3d pink-ish 'floor'
was pretty easy to fake with a few rectangular sprites. But the cubes are a
different story.

I had to get the cubes working. Otherwise there would be nothing special at
all about my storyboard. After all, it doesn't really have a story or
complements the beatmap that goes with it, because I wasn't going to make
a beatmap, just a storyboard. So it had to have at least something that would
be considered an 'achievement' or something that hasn't been done before. I
made some kind of helper program that would draw a wireframe cube which I
could rotate to try to match the cube in the video.

{@img=blog/000/20170715.png;program that draws a wireframe cube and has user \
controls on the right to change the cube's position and angles;;Yeah that \
looks horrible.}

I tried but the result looked horrible. The main culprit was that I thought
that move commands did not allow decimal numbers (spoiler: it does), which
is pretty essential if you want to have a good-looking wireframe cube. I blame
the osu!wiki for this. For some reason it stated that move commands do not
allow decimals. (I've submitted a pull request:
{@a=https://github.com/ppy/osu-wiki/pull/1660 osu-wiki PR#1660} to fix this).
I think I did try to use decimal numbers, but it gave an error when osu! tried
to parse the storyboard. Decimals {@i are} allowed, so osu! shouldn't throw an
error. I guess it's either a false memory or I managed to mess up something else
that made the command invalid.

{@img=blog/000/decimals.png;the move command specification on the osu!wiki, \
with a highlight on text that says decimals are not allowed;seriously?;I \
curse whoever wrote this.}

After failing that I think I just ditched the project, because it wasn't going
anywhere. No cubes, no glory.

{@blockquote meh apparently doing 3d stuff in storyboards is quite hard}
{@caption robin_be - July 16, 2017}

{@h3 February 2018}

After 7 months, I started looking into this again. Not sure how and why, that's
just what my git log says. On the 25th I made the first commit in that
repository, and it already had the projection code I would use for the rest of
this project. (More on that in the next section). Two days later I had a
wireframe cube storyboard that looked horrible because, again, I still didn't
know decimals were allowed in move commands. (Also I didn't scale the line width
down to 1 pixel so it looked extra bad).

{@img=blog/000/20180227.gif;a rotating wireframe cube but the lines don't \
connect and jump around;;It's a cube, but it doesn't look really good.}

{@h3 March 2018}

I then had the idea of making a large grid of pixels to make a cube. I think.
At least that's what happened, but I don't remember what I was thinking at that
time.

{@img=blog/000/20180304.gif;a rotating opaque pixelated cube;;An actual cube, \
amazing.}

It looked pretty good. It was relatively small, too. There were a few artifacts
though. Sometimes a few pixels would stay black for a frame when they should
change color. This was because I already tried to save some bytes, but it was
done in a way that basically said that the color should be black for 0
milliseconds, and somehow it actually showed black when running it. This was
fixed (way) later when Emily gave me some pointers on compressing.

{@blockquote this may have potential}
{@caption robin_be - March 4, 2018}

{@h3 May 2018}

After more weeks of hibernation and very low activity, I used some FFT output
for an attempt to make a 3d spectrum. The result is... a spectrum, but too low
quality to actually use. I could of course decrease the pixel size, but that
would enlarge the storyboard size. That was something to worry for later though,
first I needed more things to actually make something that would be interesting.

{@img=blog/000/20180517.gif;a rotating pixelated 3d spectrum;;Every good \
storyboard needs a spectrum right?}

On a very sunny sunday, I went outside and spent a good two hours solving my
rubik's cube. The reason it took so long was because I was trying to note down
every move I made, so I can use that to scramble and solve a rubik's cube in the
storyboard. But I kept messing up, either by writing down wrong moves, or by
messing up while redoing the moves I wrote down. Eventually I have a series of
moves that split up into two branches, then came together again, only to be
split again in two branches. So then I had to figure out what parts of what
branches were correct. I didn't want to start over again because this scramble
and solution didn't have many moves and I knew I had to keep the amount of
moves low so that the rubik's cube scene wouldn't become too long. So yeah, two
(if not more) hours...

{@img=blog/000/20180506.jpg;garden with 2 chairs, one having a notebook and a \
rubik's cube on it;;What a beautiful day that was.}

One other shape I had in mind was a torus. It was relatively easy to generate
points to make one, as expected. The result came out to be pretty nice.

{@img=blog/000/31052018.jpg;a pixelated green torus;;Anyone fancy a torus?}

{@h3 June 2018}

As for song choice, I had been looking at some tracks by Renard and lapfox
tracks etc in an attempt to find something energetic that would fit with a
demoscene-y storyboard. To get some inspiration for what to do in my
storyboard, I was regulary looking at {@a=https://www.youtube.com/playlist?\
list=PLzAbz5PweIWTtwwGhznh1Y6cvlo_Oo8RE BGA videos}. Eventually I stumbled
upon {@a=https://www.youtube.com/watch?v=xJqN4RUyxIE sky_delta - Exordium}. This
seemed like a really nice song to complement a demo-ish storyboard, so this
became my new pick. It also gave me some new ideas of things I could do (does
the tetrahedron flying through the tunnel look familiar?).

{@h3 July 2018}

In July, I flew to Norway and went to the {@a=http://www.solskogen.no \
Solskogen demoparty} together with Emily (best few days of my life \o/). While
being there, I told her what I was trying to do and showed what I had, which was
basically only a pixelated cube and a shaded torus. It was kind of a funny
moment when I explained that I was basically coloring pixel sprites in order to
display a spinning cube... :D. When I told her about the decimals thing, she
checked the source and actually saw that it does accept decimals. I'm not sure
what happened but I don't think I tried to test or use it after she told me...

About two weeks after that, things really took off. Emily tried to make a
wireframe cube. I was pretty sure it wasn't going to work, since I still
believed that decimals weren't possible in move commands, so I thought it
couldn't possibly look good. She took some old javascript code to draw a 3d
cube and took that as base to generate a short storyboard. We were in a call
at that time and I was helping a bit with the math aspect. It was getting pretty
late so I went to bed. The next day when I opened Discord, I was greeted with
the following picture and an accompanying storyboard file.

{@img=blog/000/27072018.png;a 3d wireframe cube in osu!;;Yup, that's one good \
looking cube.}

Seeing that was a magic moment to me. All I had seen before was my own attempt,
which was horrible. Now Emily made a cube with lines that are joined perfectly.
It was amazing.

{@blockquote fuck me for thinking it's not possible}
{@caption robin_be - July 27, 2018}

Barely a day later Emily found a method of making opaque surfaces. After that
I basically worked on it every day, because now I knew it was possible to do
some more awesome things. Also because I finally managed to fix the whole
rubik's cube movement code. It took me a looooong time to get that right and
it was very demotivating since nothing I thought of seemed to work.

{@img=blog/000/commits.png;commit graph of the project, it has a little spike \
around May and June, and a huge spike at the end of July and mid August;;\
Commit history of the project's repository.}

{@h3 August 2018}

In the beginning of August, the song of choice changed one last time. I am
subscribed to a YouTube channel named {@a=https://www.youtube.com/user/\
jjbbllkk Red Means Recording} because the person behind it makes some
interesting videos wherein he makes music using some interesting synthesizer
things (I don't actually know much about it, but I like what he's creating...).
One day he uploaded this video:
{@a=https://www.youtube.com/watch?v=sM0flzYWjcs I Made YouTube Library Music \
For You}. I took a look at it, because why not, and it had a few songs that I
though were suitable as music for this project. When I heard "Flex", I
instantly thought I found something. It has some nice buildups, which can be
useful for demo-ish stuffs, and it's a pretty nice song overall. It is a bit
long, but I figured I didn't have to fill the entire length. It ended up being
the song for the final version.

{@h2 Techniques and approach}

To make life easier, I made two important (no-brainer) decisions before even
starting. One was that I was not just going something that would dump out
storyboard commands, but a program that would actually render what I was coding.
It would be incredibly time consuming and stupid if I had to export the
storyboard and check in osu! everytime I did a little change. Not only that,
but there's zero chance that I would get the storyboard commands correctly from
the start, so that would make debugging very tedious and even more time
consuming.

The other decision was that everything had to be deterministic. By that I mean
that I should just be able to give a certain timestamp, and the program should
calculate the result that should be visible on that specific timestamp. This
means no state at all. It would be very stupid to not do it this way, because
jumping around in time would mess up everything.

<pre>
float startx = 100;
float endx = 500;
int endtime = 3000;
Cube cube = new Cube(startx, 0, 0);
void draw(int time) {
	cube.position.x += (endx - startx) / endtime;
	cube.draw();
}
</pre>
{@caption Pseudocode, moving a cube the wrong (non-deterministic) way.}

In the example above, if you would want to see what the scene looks like at time
2000, you would need to draw the scene for every millisecond until you get at
time 2000. Otherwise the cube's position won't be correct, since it wouldn't
have done the movements that are being made in the previous frames. This also
means it's not possible to go back in time.

By using the code in the example below, you can seek as much as you want. The
cube's position will always be correct for the given time, since it only depends
on the time value and not on how many times the scene has rendered before.

<pre>
float startx = 100;
float endx = 500;
int endtime = 3000;
Cube cube = new Cube(startx, 0, 0);
void draw(int time) {
	float progress = time / endtime;
	cube.position.x = (endx - startx) * progress;
	cube.draw();
}
</pre>
{@caption Pseudocode, moving a cube the correct (deterministic) way.}

That being said, generating all the storyboard commands works by rendering the
scenes from start to end while collecting information about every object's
position.

{@h3 Application}

{@img=blog/000/app.gif;gif showing the application with the tunnel + spectrum \
scene, demonstrating how the camera can be rotated by dragging the mouse\
;;Looking around in the tunnel + spectrum scene}

I decided to make the program in C#. I'm more familiar with Java, but C#
seemed like the obvious choice since making GUI stuff is very easy using Visual
Studio.

The GUI itself is pretty simple. No need for anything complicated. The most
important parts are the {@code PictureBox} where everything gets rendered and
the {@code NumericUpDown} control in the bottom left, to change the time. There
are also quite a few {@code TrackBar}s at the right, which can be used anywhere
in the code to change values to test without having to recompile and restart
the program. I didn't end up using it much at all though. I think the only time
I really had to use it was to get the rotation movements correct in the very
first scene with the wireframe cube and text.

Mouse dragging events in the preview rectangle were saved so scenes could use
that data to change angles, effectively allowing me to 'look around' in the
world.

{@img=blog/000/app2.gif;gif showing the application with the 'Emily' 3D text \
scene, demonstrating object movement with sliders and camera movement with \
mouse;;Moving Emily around :3c}

{@h3 Scenes}

The whole storyboard is divided in different scenes. For example, the tunnel
is one scene, the rubik's cube is in a different scene, ... Each scene has its
own start and stop time, so it will only be rendered if the current time falls
inbetween that. Additionally, each scene has its own framedelta, so scenes can
be rendered at a different FPS. Example: the heart is rendered at 7.4 FPS
while the torus field gets 20 FPS.

Two scenes actually have a non-constant FPS. The tunnel scene starts with a
framedelta of 900 so that it will have one frame at the start and one frame
after the tunnel has flown in. That makes the fly-in effect look smooth because
it's a single interpolation between 2 frames. After that, its framedelta
changes to 300.

The torus field scene starts with a framedelta so that the second frame will
be in sync with the audio, then it changes its framedelta so the third frame
will be in sync with the audio, and then it changes the framedelta once more
to the normal value to have a nice fps.

Note that this fps thing only applies when exporting to a storyboard, so it
doesn't affect the preview in the application.

{@h3 Exporting to storyboard}

As I kind of mentioned before, generating the storyboard is done by rendering
the scenes every 5 milliseconds, starting from the scene with the earliest
starttime to the scene with the latest endtime. While this is happening,
sprites and commands are being generated and saved into lists.

Looking closer at the code, there is an {@code Odot} class (Object: dot), which
is used to track a dot. Other objects are {@code Orect} for rectangles (3d
rectangles so actually just 4 point filled polygons), {@code Otri} (which is
not used directly, each {@code Orect} makes 4 of these: see
{@#=Opaque surfaces| opaque surfaces}) and {@code Oline} for a line between two
points. There's also {@code Odottedrect} which makes a field of {@code Odot}s
inside a rectangle (this is only used in the {@#=Rubik's cube| rubik's cube \
scene}).

<pre>
Odot dot;
public override void draw(SCENE scene) {
	float angle = scene.progress * 7f;
	vec3 pos = v3(30f * sin(angle), 20f * cos(angle), 100f);
	vec4 color = v4(1f, 0f, scene.progress, 1f);
	float size = 6f + 2f * scene.progress;
	vec4 p = project(pos);
	if (p.w > 95f) {
		dot.update(scene.time, color, p, size);
	} else {
		dot.update(scene.time, null, null, size);
	}
	dot.draw(scene.g);
}
</pre>
{@caption Sample scene that draws a dot spinning in 3d space.}

This example scene has only one dot. It spins around in 3d space (but this is
not really noticable), the color changes from red at the start to magenta at
the end, and it grows from {@code 6} units to {@code 8} units in size. The dot
only shows if its distance to the camera is more than {@code 95} units (the
{@code w} component of a {@code vec4} projection result gets set to the
distance from the projected point to the camera).

The {@code dot.draw} method is only needed to draw the dot inside the preview in
the application, it doesn't do anything during exporting.

<pre>
Sprite,Foreground,Centre,d,0,0
_M,0,0,,320,224
_C,0,0,,255,0,0
_M,0,100,,396.6,224
_C,0,100,,255,0,25
_M,0,200,300,450.7,224
_C,0,200,,255,0,51
_S,0,200,,1.1
Sprite,Foreground,Centre,d,0,0
_M,0,700,,190.1,224
_C,0,700,,255,0,178
_S,0,700,,1.2
_M,0,800,,245.1,224
_C,0,800,,255,0,204
_S,0,800,,1.3
_M,0,900,1000,321.9,224
_C,0,900,,255,0,229
</pre>
{@caption Scene above exported to a storyboard.}

Note: this storyboard code is partially compressed, see {@#=Compression| \
compression} for more information.

This scene was set to have a framedelta of {@code 100}. The resulting storyboard
has 2 sprites to represent this single dot. This is because the dot is not
visible during some time (when the distance to the camera is less than or equal
to {@code 95} units, as written in the scene's code). It is of course possible
to just hide the sprite and reuse it later when it becomes visible again. I did
this in the beginning, but the generated storyboard is larger when doing this as
opposed to just ditching the old sprite and making a new one when needed again.

Every time {@code dot.update} was called, it checked for every property
(position, color, opacity, scale) if the value is too different from the value
in the previous command. If so, it will generate a new command for the property
and add it to the list of commands. This is noticable for the scale command.
While there are move and color commands for every frame, there are only 3 scale
commands. This is because the value was rounded (in this case) to have only one
decimal, and it is of course not needed to add a command every frame if the
value didn't change from the previous frame/command. Note that this actually
needs another scale command in the beginning to have a correct start value, see
{@#=Default value quirk| default value quirk} for details.

{@h4 Last frame adjustments}

In almost every command in the generated example above, there is no endtime
specified. This is because the endtime should be the same as the starttime, and
if these are the same, the endtime can just be omitted to save space (see also
{@#=End time and end values| end time and end values}). Only the last move
command of both sprites has a different endtime. The reason behind this is that
sprites are only visible from their lowest starttime in any command to the
highest endtime in any command. This means that if the latest endtime is 900,
the sprite will be visible at time 900 and disappear at time 901. But in this
case, 900 is the time where the last frame starts, and that frame that should
be visible from time 900 to 1000 (or rather, 999). This means the last frame
will never be shown (or just for a millisecond). This leads to missing sprites,
broken objects, and this potentially leaves a blank few milliseconds in the
storyboard if that frame is the last one of its scene. To fix this, the last
command (in this case, the last move command), will have its endtime changed to
the time that the frame should end.

{@h4 Adding interpolation}

Only setting values at specific times using commands is not that great to make
movement. To have motion that's more smooth, it would need a lot of commands
with a tiny framedelta. Another options is to add (or rather, use)
interpolation. Adding interpolation between the 2d projected positions isn't
very correct, but it's not so noticable either. At least for the dots, if I try
to add interpolation to the 3d objects (spectrum, heart, text), it fails
miserably, expected. This is because those need very precise position / scaling
/ rotation, which is not possible to interpolate (see {@#=Opaque surfaces| \
opaque surfaces}).

<pre>
Sprite,Foreground,Centre,d,0,0
_M,0,0,100,320,224,396.6,224
_C,0,0,,255,0,0
_M,0,100,200,396.6,224,450.7,224
_C,0,100,,255,0,25
_C,0,200,,255,0,51
_S,0,200,,1.1
Sprite,Foreground,Centre,d,0,0
_M,0,700,800,190.1,224,245.1,224
_C,0,700,,255,0,178
_S,0,700,800,1.2,1.3
_M,0,800,900,245.1,224,321.9,224
_C,0,800,,255,0,204
_C,0,900,,255,0,229
</pre>
{@caption Same scene as before, but with movement and scaling easing applied.}

While writing this, I just remembered I didn't add interpolation for the color
because it was not needed, so only the move and scale commands are eased in this
example. Now each move command has an endtime that is different from the
starttime, and the end position is also different from the starting position.
Same for the scale commands.

You may have noticed that the ending time is again wrong since the last frame
for the first sprite is at time 300, but the last command only goes to time 200
(the same applies to the second sprite). This is because there is no next frame
to interpolate to, so this is pretty much unavoidable. The last frame adjustment
technique can't be used because that would add a still frame at the end while
it was moving before. To minimize this though, the scene's time can be extended
to be a bit longer, compensating the missing frame's duration. If a sprite goes
out of bounds, I'm also allowing one frame with out of bounds positions so it
can interpolate to the edge of the screen instead of just disappearing. Same
for when a sprite appears from an out of bounds position.

<pre>
without interpolation:
100-200: A, 200-300: B, 300-400: C

with interpolation:
100-200: A->B, 200-300: B->C, 300-400: nothing to interpolate C to
</pre>
{@caption More clear example why the last frame is missing when interpolating.}

{@h4 Phantom frames}

An issue showed up once I started interpolating positions, as shown in the
picture below. The left image is one frame, the right image is the next frame.
The image in the middle is what happens between those frames. All the squares
are being interpolated from frame 1's position to the position they should be in
frame 2. The problem is that some squares that are not visible in frame 1 should
suddenly become visible while they're being transitioned into frame 2's
position. But of course they aren't becoming visible since there's no frame that
processes it at that point in time.

The same effect is also visible in the right image. The grey surface in between
the cube's sections should still be visible. But this is a capture between that
frame and the next frame, and since that grey surface is not visible in the next
frame, it is already invisible because there's no position to interpolate to.

{@img=blog/000/cubs.png;3 captures of the rukbik's cube scene, the 2nd capture \
has missing pixels on a part that is moving;;Black hole warning.}

The solution I made was to introduce so-called "phantom frames". Frames that
don't really exist. Every scene now also had a phantom framedelta. For most
scenes, the value is the same as the framedelta because it doesn't need phantom
processing. Every command that is generated by a phantom frame is marked as a
phantom command. Since sprites are never reused, only the very first and last
commands are being checked if they're phantom commands. If they are, they get
"promoted" to a real command. All the other phantom commands are just ditched.

The only scenes that used phantom frames/commands are the {@#=Rubik's cube| \
rubik's cube} and {@#=Starfield torus| starfield torus} scenes.

{@h4 Default value quirk}

this actually also made things easier (phantom commands)

{@h4 Output report}

{@img=blog/000/export.png;image of the console showing how many Kb each scene \
is, and usage count of sprites and ease commands;;The output when exporting \
to a storyboard file.}

{@h3 Type 'library'}

{@h3 3d projection}

{@blockquote "use the tools that you have" on a whole new level}

{@h4 Intermezzo: .NET float parsing bullshit}

{@blockquote (times I have been fucked by C# treating a comma as decimal
separator for float.Parse() and using a . as thousand separator)++}
{@caption robin_be - March 4, 2018}

For some reason C# (or .NET in general?) parses floats by using the 'Region
and Language' that has been setup in the control panel. In my case, that
means it would use a {@code ,} as decimal separator and a {@code .} as
thousand separator. It's a pretty easy fix but for some reason it usually
takes me a while to realize that that's what causing the weird
{@code float.Parse} behavior that I'm seeing.

<pre>
var c = (CultureInfo) Thread.CurrentThread.CurrentCulture.Clone();
c.NumberFormat.NumberDecimalSeparator = ".";
Thread.CurrentThread.CurrentCulture = c;
</pre>
{@caption Take that, annoying region and language settings!}

{@h3 Rasterisation}

{@h3 Opaque surfaces}

{@h3 Opaque 3d objects}

{@h3 FFT}

{@h3 Font rendering}

{@h2 Scene breakdown}

{@h3 Rubik's cube}

{@h3 Starfield torus}

{@h2 Compression}

Everything about reducing the size of the resulting storyboard file.

{@h3 Line endings}

{@h3 Sprite names}

{@h3 Sprite sizes}

{@h3 Enum member values}

{@h3 Initial position}

{@h3 Rounding decimal values}

{@h3 End time and end values}

{@h3 Combining multiple fade/scale commands}

One more thing to save space (and actually make things smoother at the same
time) is to combine series of fade/scale commands into only one command by
applying an easing that fits with the way the value changes. Consider the
following example:

<pre>
Odot dot;
public override void draw(SCENE scene) {
	float angle = scene.progress * 7f;
	vec3 pos = v3(20f * sin(angle), 20f * cos(angle), 100f);
	vec4 p = project(pos);
	float size = progressx(130f, 70f, p.w) * 12f;
	dot.update(scene.time, v4(1f), p, size);
}
</pre>
{@caption Simple scene with a spinning dot that gets larger as it gets \
closer to the camera.}

<pre>
4,3,1,d,0,0
_S,0,0,,0.3
_S,0,100,,0.5
_S,0,200,,0.8
_S,0,300,,1.3
_S,0,400,,1.6
_S,0,600,,1.3
_S,0,700,,0.8
_S,0,800,,0.5
_S,0,900,,0.3
</pre>
{@caption Storyboard code generated by the above scene. Note that I removed \
the move commands for this example.}

In the generated storyboard code you can see that the value goes up, and then
goes down again. The idea is to split all these commands of the same category
in batches where the value changes in the same direction (goes up or down).
Then one single command gets made with the start data of the first one and the
end data of the last one. For each batch, go through all possible easing
equations that osu! has to offer and see by using which easing the values get
the closest to the target values given at each command in the batch. The best
one is being determined by the score given to it, which depends on the average
difference and the maximum difference between the eased values and the target
values.

{@img=blog/000/easing.png;a graph showing the target value and values \
calculated with each easing;;Graph with easings for the first batch. Red is \
the target, green is the one with the best score.}

Since the scale value in the previous example goes up once and then down once,
the commands are split into two batches. The graph above is a visualisation of
the first batch. The red line represents the target values, the green line
represents the values with easing 15 applied, which is the easing with the best
score.

The resulting two scale commands use easings 15 (sine in) and 16 (sine out),
which makes sense since the dot's position (and thus size) was largely
determined by a sine wave motion.

<pre>
4,3,1,d,0,0
_S,15,0,400,0.33,1.62
_S,16,500,900,1.61,0.33
</pre>
{@caption Storyboard commands for the same scene, but with easing as explained \
applied.}

According to the {@#=Output report| output report}, combining commands like this
was applied 11655 times, saving 61211 commands and about 760KB. On top of the
space savings, this also means the scaling or fading will be a bit smoother
compared to chained linear interpolated commands. The reason that the linear
interpolation was applied so many times is probably due to many batches only
having two commands.

{@img=blog/000/easingusage.png;bar-graph with pink bars... too much data to \
type down sorry;;Graph showing how much each easing is applied (slightly off). \
Note the logarithmic x-axis.}

Now I'm wondering why I didn't try to do this with the move commands... On a
second thought, this would be very hard to do for the move commands. Fade and
scale are only single float values, so it can only go up or down. That means
it's relatively easy to split batches of commands depending on whether the value
is going up or down. It would be way more complex to do this for move commands,
since those have two values that change instead of only one.

{@h3 Shorthand discoveries}

(the things in end time and end values are also shorthands)

when looking at wiki, shorthands notices, checked github, found page

This page about shorthands is not linked anywhere on the wiki though, so it's
very hard to find. To be more precise, it is linked on the Sitemap page, but
that page is not linked anywhere. But wait, there's more! The Sitemap page is
linked from a page named {@code Main_Page}, but that page doesn't even exist
on the live version, it only exists in the osu!wiki repository. I don't even...
I made a pull request: {@a=https://github.com/ppy/osu-wiki/pull/1661 osu-wiki \
PR#1661} to add a link to the shorthand page, so hopefully that will be fixed
soon.

{@b Note:} my pull request was merged before I even finished this blogpost, so
yey!

{@h3 Variables}

(also variable section is 256)

compression, leave out end values, fixed some bugs I had by trying to reduce color 0, 0, 0

{@img=blog/000/minify.png;image of the console showing variable process \
progress and the top variable replacements;;The output when minifying using \
variables.}

{@h4 Staircase of death}

{@blockquote we should call this the staircase of death}
{@caption Emily - August 26, 2018}

{@h5 Upload failure}

{@h4 Stable vs Lazer}

Only sequential nesting is possible when using variables. However, in Lazer,
proper nesting seems to be supported.

{@h2 Related work}

dualife, flower trip, (others I can't remember atm)

those had 3d wireframe objects, back in 2016. I found out about them when I
was almost finished with my storyboard. I wish I saw them earlier, so I would
know that decimals in move commands are allowed. Still, bad from my end that
I didn't try enough to actually see if it was possible.

{@hr}

{@blockquote also, turns out writing a blogpost takes a long while &lt;.&lt;}
{@caption robin_be - September 3, 2018}



1535883433

Making of my osu! storyboard demo

02 Sep 2018
--------------------------------------------------------------------------------
{@img=blog/000/ytthumb.png;fragmented heart scene;YouTube thumbnail}

{@h2 Links}

{@ul
  {@li {@a=https://youtube.com/watch?v=bOGJWGJOMOk YouTube video showing the \
storyboard}}
  {@li {@a=https://old.ppy.sh/b/1756941?m=0 Beatmap on osu! website}}
  {@li {@a=https://github.com/yugecin/osusb1 GitHub repo}}
  {@li {@a=https://github.com/yugecin/osusb1/releases GitHub releases}}
}

{@hr}

{@h2 Contents}

~INDEXGOESHERE~

{@hr}

{@h2 Prologue}

First things first, if you don't know what {@a=https://osu.ppy.sh/home osu!} is,
it's a rythm game where you have to click circles which are (hopefully) synced
with the music playing. There are multiple game modes, but the circle clicking
one (also called 'osu!standard') is the most popular one.

Beatmaps (which basically contain the music & metadata and describe when and
where circles, sliders, spinners, etc should be) can also include a video and/or
a storyboard. A storyboard, in its bare essence, describes a series of images
and each image can have a timed series of transformations that will be applied
to it (positioning/rotating/scaling/coloring).

If you're still completely in the dark, here's a nice video that shows what
gameplay with a storyboard in the background looks like (epilepsy warning):
{@a=https://www.youtube.com/watch?v=D112SbYXR3o YouTube: How beautiful can osu!
REALLY be? - Episode 2 [Sweet Dreams]}. Everything that happens in the
background is done using the storyboard. Amazing, right? Note that this is auto
mode, it's not a human playing.

{@h2 Backstory and timeline}

{@blockquote
robin_be: is anyone familiar with storyboarding?<br/>
Emily | Sunpy: I am somewhat familiar with it. But I havent done any
storyboarding in along time. But im guessing you are thinking about opsu
port?<br/>
robin_be: nah I'm planning something that's gonna fail miserably<br/>
robin_be: what is an .osb file?
}
{@caption yeah... silly me in #offtopic in Knorke discord, July 12th 2017}

{@h3 July 2017}

I can't exactly remember why I wanted to try out storyboarding. I think it's
because I wanted to try something different. If you recognize my username,
you might be familiar with my osu! cursordance videos. I made a few of those,
after being amazed by the work by
{@a=https://www.youtube.com/user/MrRheinerZufall MrRheinerZufall}. (This was
back in mid-2016). (I even
forked {@a=https://github.com/itdelatrisu/opsu opsu!} into {@a=https://github\
.com/yugecin/opsu-dance opsu!dance} to add cursordance-y stuff to it). I tried
to add something new or original into every video. If I didn't do that, every
video felt basically the same to me, and I don't like that. I hate seeing or
hearing the same thing over and over again. I don't listen to the (mainstream)
radio because after a while you notice they're always playing the same songs.
I don't understand how other people can stand that. Anyways, trying to have
something fresh every new video was getting pretty hard since I would say I'm
not really a person with lots of creativity. So I guess one day I just
randomly thought about doing something with storyboards.

I'm an avid follower of {@a=https://en.wikipedia.org/wiki/Demoscene the
demoscene} and the first idea I had (I think) was to try to remake the demo
{@a=https://www.youtube.com/watch?v=UYU5POqHdeA "What are you syncing about?"
by Ninjadev}, or at least some of the 2d parts. I saw it being released on the
live stream of the Revision 2017 demoparty. It was very nice to watch and it
looked like it would be possible to remake some of the parts in an osu!
storyboard. Especially the spaceship part that starts at 1m15s would be very
nice to see. I managed to hand-write storyboard commands to make everything
(except for the cubes and text) up to the 30s mark. The 3d pink-ish 'floor'
was pretty easy to fake with a few rectangular sprites. But the cubes are a
different story.

I had to get the cubes working. Otherwise there would be nothing special at
all about my storyboard. After all, it doesn't really have a story or
complements the beatmap that goes with it, because I wasn't going to make
a beatmap, just a storyboard. So it had to have at least something that would
be considered an 'achievement' or something that hasn't been done before. I
made some kind of helper program that would draw a wireframe cube which I
could rotate to try to match the cube in the video.

{@img=blog/000/20170715.png;program that draws a wireframe cube and has user \
controls on the right to change the cube's position and angles;;Yeah that \
looks horrible.}

I tried but the result looked horrible. The main culprit was that I thought
that move commands did not allow decimal numbers (spoiler: it does), which
is pretty essential if you want to have a good-looking wireframe cube. I blame
the osu!wiki for this. For some reason it stated that move commands do not
allow decimals. (I've submitted a pull request:
{@a=https://github.com/ppy/osu-wiki/pull/1660 osu-wiki PR#1660} to fix this).
I think I did try to use decimal numbers, but it gave an error when osu! tried
to parse the storyboard. Decimals {@i are} allowed, so osu! shouldn't throw an
error. I guess it's either a false memory or I managed to mess up something else
that made the command invalid.

{@img=blog/000/decimals.png;the move command specification on the osu!wiki, \
with a highlight on text that says decimals are not allowed;seriously?;I \
curse whoever wrote this.}

After failing that I think I just ditched the project, because it wasn't going
anywhere. No cubes, no glory.

{@blockquote meh apparently doing 3d stuff in storyboards is quite hard}
{@caption robin_be - July 16, 2017}

{@h3 February 2018}

After 7 months, I started looking into this again. Not sure how and why, that's
just what my git log says. On the 25th I made the first commit in that
repository, and it already had the projection code I would use for the rest of
this project. (More on that in the next section). Two days later I had a
wireframe cube storyboard that looked horrible because, again, I still didn't
know decimals were allowed in move commands. (Also I didn't scale the line width
down to 1 pixel so it looked extra bad).

{@img=blog/000/20180227.gif;a rotating wireframe cube but the lines don't \
connect and jump around;;It's a cube, but it doesn't look really good.}

{@h3 March 2018}

I then had the idea of making a large grid of pixels to make a cube. I think.
At least that's what happened, but I don't remember what I was thinking at that
time.

{@img=blog/000/20180304.gif;a rotating opaque pixelated cube;;An actual cube, \
amazing.}

It looked pretty good. It was relatively small, too. There were a few artifacts
though. Sometimes a few pixels would stay black for a frame when they should
change color. This was because I already tried to save some bytes, but it was
done in a way that basically said that the color should be black for 0
milliseconds, and somehow it actually showed black when running it. This was
fixed (way) later when Emily gave me some pointers on compressing.

{@blockquote this may have potential}
{@caption robin_be - March 4, 2018}

{@h3 May 2018}

After more weeks of hibernation and very low activity, I used some FFT output
for an attempt to make a 3d spectrum. The result is... a spectrum, but too low
quality to actually use. I could of course decrease the pixel size, but that
would enlarge the storyboard size. That was something to worry for later though,
first I needed more things to actually make something that would be interesting.

{@img=blog/000/20180517.gif;a rotating pixelated 3d spectrum;;Every good \
storyboard needs a spectrum right?}

On a very sunny sunday, I went outside and spent a good two hours solving my
rubik's cube. The reason it took so long was because I was trying to note down
every move I made, so I can use that to scramble and solve a rubik's cube in the
storyboard. But I kept messing up, either by writing down wrong moves, or by
messing up while redoing the moves I wrote down. Eventually I have a series of
moves that split up into two branches, then came together again, only to be
split again in two branches. So then I had to figure out what parts of what
branches were correct. I didn't want to start over again because this scramble
and solution didn't have many moves and I knew I had to keep the amount of
moves low so that the rubik's cube scene wouldn't become too long. So yeah, two
(if not more) hours...

{@img=blog/000/20180506.jpg;garden with 2 chairs, one having a notebook and a \
rubik's cube on it;;What a beautiful day that was.}

One other shape I had in mind was a torus. It was relatively easy to generate
points to make one, as expected. The result came out to be pretty nice.

{@img=blog/000/31052018.jpg;a pixelated green torus;;Anyone fancy a torus?}

{@h3 June 2018}

As for song choice, I had been looking at some tracks by Renard and lapfox
tracks etc in an attempt to find something energetic that would fit with a
demoscene-y storyboard. To get some inspiration for what to do in my
storyboard, I was regulary looking at {@a=https://www.youtube.com/playlist?\
list=PLzAbz5PweIWTtwwGhznh1Y6cvlo_Oo8RE BGA videos}. Eventually I stumbled
upon {@a=https://www.youtube.com/watch?v=xJqN4RUyxIE sky_delta - Exordium}. This
seemed like a really nice song to complement a demo-ish storyboard, so this
became my new pick. It also gave me some new ideas of things I could do (does
the tetrahedron flying through the tunnel look familiar?).

{@h3 July 2018}

In July, I flew to Norway and went to the {@a=http://www.solskogen.no \
Solskogen demoparty} together with Emily (best few days of my life \o/). While
being there, I told her what I was trying to do and showed what I had, which was
basically only a pixelated cube and a shaded torus. It was kind of a funny
moment when I explained that I was basically coloring pixel sprites in order to
display a spinning cube... :D.

About two weeks after that, things really took off. Emily tried to make a
wireframe cube. I was pretty sure it wasn't going to work, since I still
believed that decimals weren't possible in move commands, so I thought it
couldn't possibly look good. She took some old javascript code to draw a 3d
cube and took that as base to generate a short storyboard. We were in a call
at that time and I was helping a bit with the math aspect. It was getting pretty
late so I went to bed. The next day when I opened Discord, I was greeted with
the following picture and an accompanying storyboard file.

{@img=blog/000/27072018.png;a 3d wireframe cube in osu!;;Yup, that's one good \
looking cube.}

Seeing that was a magic moment to me. All I had seen before was my own attempt,
which was horrible. Now Emily made a cube with lines that are joined perfectly.
It was amazing.

{@blockquote fuck me for thinking it's not possible}
{@caption robin_be - July 27, 2018}

Barely a day later Emily found a method of making opaque surfaces. After that
I basically worked on it every day, because now I knew it was possible to do
some more awesome things. Also because I finally managed to fix the whole
rubik's cube movement code. It took me a looooong time to get that right and
it was very demotivating since nothing I thought of seemed to work.

{@img=blog/000/commits.png;commit graph of the project, it has a little spike \
around May and June, and a huge spike at the end of July and mid August;;\
Commit history of the project's repository.}

In the beginning og August, the song of choice changed one last time. I am
subscribed to a YouTube channel named {@a=https://www.youtube.com/user/\
jjbbllkk Red Means Recording} because the person behind it makes some
interesting videos wherein he makes music using some interesting synthesizer
things (I don't actually know much about it, but I like what he's creating...).
One day he uploaded this video:
{@a=https://www.youtube.com/watch?v=sM0flzYWjcs I Made YouTube Library Music \
For You}. I took a look at it, because why not, and it had a few songs that I
though were suitable as music for this project. When I heard "Flex", I
instantly thought I found something. It has some nice buildups, which can be
useful for demo-ish stuffs, and it's a pretty nice song overall. It is a bit
long, but I figured I didn't have to fill the entire length. It ended up being
the song for the final version.

{@h2 Techniques and approach}

To make life easier, I made two important (no-brainer) decisions before even
starting. One was that I was not just going something that would dump out
storyboard commands, but a program that would actually render what I was coding.
It would be incredibly time consuming and stupid if I had to export the
storyboard and check in osu! everytime I did a little change. Not only that,
but there's zero chance that I would get the storyboard commands correctly from
the start, so that would make debugging very tedious and even more time
consuming.

The other decision was that everything had to be deterministic. By that I mean
that I should just be able to give a certain timestamp, and the program should
calculate the result that should be visible on that specific timestamp. This
means no state at all. It would be very stupid to not do it this way, because
jumping around in time would mess up everything.

<pre>
float startx = 100;
float endx = 500;
int endtime = 3000;
Cube cube = new Cube(startx, 0, 0);
void draw(int time) {
	cube.position.x += (endx - startx) / endtime;
	cube.draw();
}
</pre>
{@caption Pseudocode, moving a cube the wrong (non-deterministic) way.}

In the example above, if you would want to see what the scene looks like at time
2000, you would need to draw the scene for every millisecond until you get at
time 2000. Otherwise the cube's position won't be correct, since it wouldn't
have done the movements that are being made in the previous frames. This also
means it's not possible to go back in time.

By using the code in the example below, you can seek as much as you want. The
cube's position will always be correct for the given time, since it only depends
on the time value and not on how many times the scene has rendered before.

<pre>
float startx = 100;
float endx = 500;
int endtime = 3000;
Cube cube = new Cube(startx, 0, 0);
void draw(int time) {
	float progress = time / endtime;
	cube.position.x = (endx - startx) * progress;
	cube.draw();
}
</pre>
{@caption Pseudocode, moving a cube the correct (deterministic) way.}

That being said, generating all the storyboard commands works by rendering the
scenes from start to end while collecting information about every object's
position.

{@h3 Application}

{@img=blog/000/app.gif;gif showing the application with the tunnel + spectrum \
scene, demonstrating how the camera can be rotated by dragging the mouse\
;;Looking around in the tunnel + spectrum scene}

I decided to make the program in C#. I'm more familiar with Java, but C#
seemed like the obvious choice since making GUI stuff is very easy using Visual
Studio. Stuff like mouse handling and events is also more straight forward in
C# so I didn't even really consider using Java.

The GUI itself is pretty simple. No need for anything complicated. The most
important parts are the {@code PictureBox} where everything gets rendered and
the {@code NumericUpDown} control in the bottom left, to change the time. There
are also quite a few {@code TrackBar}s at the right, which can be used anywhere
in the code to change values to test without having to recompile and restart
the program. I didn't end up using it much at all though. I think the only time
I really had to use it was to get the rotation movements correct in the very
first scene with the wireframe cube and text.

Mouse dragging events in the preview rectangle were saved so scenes could use
that data to change angles, effectively allowing me to 'look around' in the
world.

{@img=blog/000/app2.gif;gif showing the application with the 'Emily' 3D text \
scene, demonstrating object movement with sliders and camera movement with \
mouse;;Moving Emily around :3c}

{@h3 Scenes}

The whole storyboard is divided in different scenes. For example, the tunnel
is one scene, the rubik's cube is in a different scene, ... Each scene has its
own start and stop time, so it will only be rendered if the current time falls
inbetween that. Additionally, each scene has its own framedelta, so scenes can
be rendered at a different FPS. Example: the heart is rendered at 7.4 FPS
while the torus field gets 20 FPS.

Two scenes actually have a non-constant FPS. The tunnel scene starts with a
framedelta of 900 so that it will have one frame at the start and one frame
after the tunnel has flown in. That makes the fly-in effect look smooth because
it's a single interpolation between 2 frames. After that, its framedelta
changes to 300.

The torus field scene starts with a framedelta so that the second frame will
be in sync with the audio, then it changes its framedelta so the third frame
will be in sync with the audio, and then it changes the framedelta once more
to the normal value to have a nice fps.

Note that this fps thing only applies when exporting to a storyboard, so it
doesn't affect the preview in the application.

{@h3 Exporting to storyboard}

As I kind of mentioned before, generating the storyboard is done by rendering
the scenes every 5 milliseconds, starting from the scene with the earliest
starttime to the scene with the latest endtime. While this is happening,
sprites and commands are being generated and saved into lists.

{@h4 Generating commands}

Looking closer at the code, there is an {@code Odot} class (Object: dot), which
is used to track a dot. Other objects are {@code Orect} for rectangles (3d
rectangles so actually just 4 point filled polygons), {@code Otri} (which is
not used directly, each {@code Orect} makes 4 of these: see
{@ia=#opaque_surfaces opaque surfaces}) and {@code Oline} for a line between two
points. There's also {@code Odottedrect} which makes a field of {@code Odot}s
inside a rectangle (this is only used in the {@ia=rubikscube #Rubik's cube \
scene}).

<pre>
Odot dot;
void draw(SCENE scene) {
	float angle = scene.progress * 20f;
	vec3 pos = v3(30f * sin(angle), 20f * cos(angle), 20f);
	vec3 color = v4(1f, 0f, scene.progress, 1f);
	float size = 12f;
	vec4 p = project(pos);
	if (p.w &lt; 300f) {
		dot.update(scene.time, color, p.xy, size);
	} else {
		dot.update(scene.time, null, null, size);
	}
	dot.draw(scene.graphics);
}
</pre>

While this is happening, the
position of every rendered object is saved into a structure that represents a
move command, which then is saved into a list that contains all the move
{@b REWRITE THIS}
commands for that object. But before the command for that time is added to the
list, it's being checked if it differs from the previous command. If the
position doesn't change, it's not necessary to add another move command because
the sprite would already be in the correct position. Note that this also
depends on how much decimals are configured to be printed at the time of
processing that object, because that is pretty much configurable per scene and
object. The same happens for rotating, scaling, coloring and fading.

By working this way, the scenes only have to alter the objects and not worry
about how the storyboard commands should be generated.

// TODOFDKL

{@h4 Rounding decimal values}

stack

{@h4 Adding interpolation}

{@h4 Phantom frames}

An issue showed up once I started interpolating sprites, as shown in the picture
below. The left image is one frame, the right image is the next frame. The image
in the middle is what happens between those frames. All the squares are being
interpolated from frame 1's position to the position they should be in frame 2.
The problem is that some squares that are not visible in frame 1 should suddenly
become visible while they're being transitioned into frame 2's position. But of
course they aren't becoming visible since there's no frame that processes it at
that point in time.

The same effect is also visible in the right image. The grey surface in between
the cube's sections should still be visible. But this is a capture between that
frame and the next frame, and since that grey surface is not visible in the next
frame, it is already invisible because there's no position to interpolate to.

{@img=blog/000/cubs.png;3 captures of the rukbik's cube scene, the 2nd capture \
has missing pixels on a part that is moving;;Black hole warning.}

The solution I made was to introduce so-called "phantom frames". Frames that
don't really exist. Every scene now also has a phantom framedelta. For most
scenes, the value is the same as the framedelta because it doesn't need phantom
processing. When generating the storyboard commands at the end, every phantom
frame is being examined to check if it introduces an object that wasn't visible
before. If it does, that phantom frame is "promoted" to a real frame. All the
other phantom frames are just being dropped.

The same applies to the reverse problem, when objects don't stay long enough
because they disappear between frames. In that case, the last frame is used as
the end position, even if it's a phantom frame.


{@h4 Combining multiple fade/scale commands}

{@h4 Default value quirk}

{@h4 Output report}

{@img=blog/000/export.png;image of the console showing how many Kb each scene \
is, and usage count of sprites and ease commands;;The output when exporting \
to a storyboard file.}

{@h3 Type 'library'}

{@h3 3d projection}

{@h3 Rasterisation}

{@h3 Opaque surfaces}

{@h3 Opaque 3d objects}

{@h3 FFT}

{@h3 Font rendering}

{@blockquote (times I have been fucked by C# treating a comma as decimal
separator for float.Parse() and using a . as thousand separator)++}
{@caption robin_be - March 4, 2018}

For some reason C# (or .NET in general?) parses floats by using the 'Region
and Language' that has been setup in the control panel. In my case, that
means it would use a {@code ,} as decimal separator and a {@code .} as
thousand separator. It's a pretty easy fix but for some reason it usually
takes me a while to realize that that's what causing the weird
{@code float.Parse} behavior that I'm seeing.

<pre>
var c = (CultureInfo) Thread.CurrentThread.CurrentCulture.Clone();
c.NumberFormat.NumberDecimalSeparator = ".";
Thread.CurrentThread.CurrentCulture = c;
</pre>
{@caption Take that, annoying region and language settings!}




{@blockquote "use the tools that you have" on a whole new level}

{@h2 Scene breakdown}

{@h2 Compression}

{@h3 Line endings}

{@h3 Sprite names}

{@h3 Sprite sizes}

{@h3 End time and end values}

{@h3 Shorthand discoveries}

(the things in end time and end values are also shorthands)

when looking at wiki, shorthands notices, checked github, found page

This page about shorthands is not linked anywhere on the wiki though, so it's
very hard to find. To be more precise, it is linked on the Sitemap page, but
that page is not linked anywhere. But wait, there's more! The Sitemap page is
linked from a page named {@code Main_Page}, but that page doesn't even exist
on the live version, it only exists in the osu!wiki repository. I don't even...
I made a pull request: {@a=https://github.com/ppy/osu-wiki/pull/1661 osu-wiki \
PR#1661} to add a link to the shorthand page, so hopefully that will be fixed
soon.

{@h3 Enum members}

{@h3 Variables}

compression, leave out end values, fixed some bugs I had by trying to reduce color 0, 0, 0

{@img=blog/000/minify.png;image of the console showing variable process \
progress and the top variable replacements;;The output when minifying using \
variables.}

{@h4 Staircase of death}

{@blockquote we should call this the staircase of death}
{@caption Emily - August 26, 2018}

{@h5 Upload failure}

{@h4 Stable vs Lazer}

Only sequential nesting is possible when using variables. However, in Lazer,
proper nesting seems to be supported.

{@h2 Related work}

dualife, flower trip, (others I can't remember atm)

those had 3d wireframe objects, back in 2016. I found out about them when I
was almost finished with my storyboard. I wish I saw them earlier, so I would
know that decimals in move commands are allowed. Still, bad from my end that
I didn't try enough to actually see if it was possible.

{@hr}

{@blockquote also, turns out writing a blogpost takes a long while &lt;.&lt;}
{@caption robin_be - September 3, 2018}


